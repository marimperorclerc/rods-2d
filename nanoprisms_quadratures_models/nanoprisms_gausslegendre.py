r"""
This model describes the scattering of light by nanoprisms using a combination of numerical integration techniques.

Definition
----------
The Gauss-Legendre quadrature is a form of Gaussian quadrature for approximating the definite integral of a function.
This method is based on the generation of a set of points on the unit sphere and their associated weights.
Here it is used to perform the orientational averaging of the scattering intensity. 
The quadrature input parameter is the number of points per angle (theta and phi), 
the total number of points on the sphere being equals to the square of this number.

References
----------

Authorship and Verification
---------------------------

* **Authors:** Jules Marcone, Marianne Imperor-Clerc, Nicolas Ratel-Ramond, Mokhtari Sara **Date:** 07/09/2025
* **Last Modified by:** Sara Mokhtaru **Date:** 16/10/2025
* **Last Reviewed by:** **Date:**

"""
name = "nanoprisms_gausslegendre"
title = "nanoprisms Gauss-Legendre quadrature"
description = """
        nanoprisms Gauss-Legendre quadrature"""

category = "plugin"

import numpy as np
from numpy import inf
from prismformfactors import *
import numpy as np
import matplotlib.pyplot as plt
import time


#             ["name", "units", default, [lower, upper], "type", "description"],
parameters = [["sld", "1e-6/Ang^2", 126., [-inf, inf], "sld",
               "nanoprism scattering length density"],
              ["sld_solvent", "1e-6/Ang^2", 9.4, [-inf, inf], "sld",
               "Solvent scattering length density"],
              ["n_sides", "", 5, [3, 50], "",
               "n_sides"],
              ["R_ave", "Ang", 500, [0., inf], "volume",
               "Average radius"],
              ["L", "Ang", 5000, [0., inf], "volume",
               "length"],
              ["npoints_gauss",     "",        150, [0, 10e4],   "",
                "points for each angle for the Lebedev quadrature (ntotal = npoints**2)"],

               ]


def volume(nsides,Rave,L):
    nsides=int(nsides)
    edge = functions.edge_from_gyration_radius(nsides,Rave)
    return functions.volume_nanoprism(nsides,edge,L)

def Iqabc(qa,qb,qc,nsides,Rave,L): # proportionnal to the volume**2
    nsides=int(nsides)
    edge = functions.edge_from_gyration_radius(nsides,Rave)
    intensity=formfactor.I_nanoprism([qa,qb,qc],nsides,edge,L)
    return intensity



################################################# Gauss Legendre integration ##################################################


def gauss_legendre_sphere(npoints_gauss: int):
    from sasmodels.gengauss import gengauss
    from numpy.polynomial.legendre import leggauss 
    """
    Generates n_points of Gauss-Legendre on the unit sphere in Cartesian coordinates (x,y,z) 
    and their associated weights.
    Parameters
    ----------
    n_points : int
        Number of Gauss-Legendre points to generate per angle (total = n_points**2).

    Returns
    -------
    points : ndarray, shape (n_points**2, 3)
        Cartesian coordinates of the points on the unit sphere.
    weights : ndarray, shape (n_points**2,)
        Weights associated with each point for integration over the sphere.

    """
    # If we want to use the file generated by gengauss.py: not working right now
    # Retreive the points and weights from the file generated by gengauss.py
    #gengauss(n_points, path) # génère le fichier gauss(n_points).c dans le répertoire path
    # file_gauss = path + f"/gauss{n_points}.c" # retreive the file
    
    # Instead we use leggauss from numpy (was also done in gengauss.py)
    npoints_gauss = int(npoints_gauss)
    GaussZ, GaussWt = leggauss(npoints_gauss) # voir temps d'exécution
    # GaussZ, GaussWt = np.loadtxt(file_gauss, unpack=True, comments='//')  # charge les points et poids

    # θ : Gauss-Legendre on [0, pi]
    z_theta, w_theta = GaussZ, GaussWt
    theta = 0.5 * (z_theta * (np.pi - 0) + 0 + np.pi) # from [-1,1] to [0,pi], angle = 0.5 * (z * (b - a) + (a + b))
    weights_theta = 0.5 * (np.pi - 0) * w_theta # formula : w = 0.5 * (b - a)

    # φ : Gauss-Legendre on [0, 2pi]
    z_phi, w_phi = GaussZ, GaussWt
    # Linear transformation for phi
    phi = np.linspace(0, 2*np.pi, npoints_gauss, endpoint=False)
    weights_phi = np.full(npoints_gauss, 2*np.pi / npoints_gauss)

    # Grille (θ, φ) :  grid of npoints_gauss x npoints_gauss
    # for each point of θ, we associate all points of φ and vice versa
    theta_grid, phi_grid = np.meshgrid(theta, phi, indexing='ij')
    w_theta_grid, w_phi_grid = np.meshgrid(weights_theta, weights_phi, indexing='ij') 

    # Coordonnées x, y, z
    x = np.sin(theta_grid) * np.cos(phi_grid)
    y = np.sin(theta_grid) * np.sin(phi_grid)
    z = np.cos(theta_grid)

    # Poids totaux
    weights = w_theta_grid * w_phi_grid * np.sin(theta_grid)/(4*np.pi)  # sin(theta) comes from the Jacobian in spherical coordinates
    points = np.column_stack((x.ravel(), y.ravel(), z.ravel())) # ravel() to convert multi dimensional array to 1D array
    weights = weights.ravel() # multi dimensional array to 1D array


    return points, weights

def plot_gauss_sphere(npoints_gauss, figsize=(7,7)):
    """
    3D representation of Gauss-Legendre points on the unit sphere.
    Parameters
    ----------
    npoints_gauss : int
        Number of points to generate and display.
    figsize : tuple
        Size of the figure.
    
    """
    pts, w = gauss_legendre_sphere(npoints_gauss)  # shape (npoints,3)

    fig = plt.figure(figsize=figsize)
    ax = fig.add_subplot(111, projection="3d")
    ax.scatter(pts[:,0], pts[:,1], pts[:,2], s=10, alpha=0.6)

    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_zlabel("z")
    ax.set_title(f"Gauss-Legendre points on the unit sphere, ({len(pts)} points in total)")
    ax.set_box_aspect([1,1,1])  
    plt.show()  

def Iq(q, sld, sld_solvent, nsides:int, Rave, L, npoints_gauss:int):
    """
    Integration over the unit sphere with Gauss-Legendre points.

    Parameters
    ----------
    q : float ou array
        Norm of the scattering vector
    sld, sld_solvent : density contrasts
    nsides, Rave, L : geometric parameters of the nanoprism
    npoints_gauss : int
        Number of Gauss-Legendre points per dimension (total npoints_gauss**2)
    Returns
    -------
    Iq : ndarray
        Scattering intensity averaged over all orientations
    time_gauss : float
        Execution time of the function in seconds
    n_points_total : int
        Total number of points used in the quadrature (npoints_gauss**2)
    """

    time_start = time.time()
    nsides = int(nsides)
    q = np.atleast_1d(q)  # make sure q is a 1D table
    n_points_total = int(npoints_gauss)**2


    q_unit, w = gauss_legendre_sphere(npoints_gauss)   # shape (npoints, 3)

    # Projections
    qa = q[:, np.newaxis] * q_unit[:, 0][np.newaxis, :]
    qb = q[:, np.newaxis] * q_unit[:, 1][np.newaxis, :]
    qc = q[:, np.newaxis] * q_unit[:, 2][np.newaxis, :]

    # Compute intensity
    intensity = Iqabc(qa, qb, qc, nsides, Rave, L)  # shape (nq, npoints)

    # Uniform average over the sphere
    integral = np.sum(w[np.newaxis, :] * intensity, axis=1)
    time_end = time.time()
    time_gauss = time_end - time_start

    print(f'Execution time Gauss-Legendre with {int(npoints_gauss)**2} points: {time_gauss:.4f} seconds')

    return integral * (sld - sld_solvent)**2

Iq.vectorized = True  # Iq can be vectorized






